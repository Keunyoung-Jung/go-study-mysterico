# 08 Error
이번 장에서는 에러처리에 대해서 설명합니다.

## 에러와 예외
둘은 비슷하지만 완전히 같은 의미는 아닙니다.

우선, 공통점은 발생하면 프로그램이 정상진행이 불가피하여 프로그램을 `종료`한다는 점입니다.
그리고 과거에는 예외처리가 따로 존재하지 않았을 때는 모두 에러라고도 불렀다고 합니다.

하지만 가장 큰 `차이점`은 회피가 가능한지, 불가능하지로 분류됩니다.

`오류`의 경우, 시스템이 종료되어야 할 수준의 상황과 같이 수습할 수 없는 심각한 문제를 의미해 개발자가 미리 예측해 `방지가 불가능`하고 따라서 `회피가 불가능`합니다.
반면 `예외`의 경우, 개발자가 구현한 로직에서 발생한 실수나 `사용자의 영향`에 의해 발생하기 떄문에 오류와 달리 개발자가 미리 예측하여 방지가 가능 즉, `회피가 가능`합니다.

## 에러 타입
Go에서는 기본으로 제공하는 error 라는 interface 타입을 가집니다.
아래와 같이 이용하면 됩니다. 즉, Error() string 이라는 메서드를 가집니다.
```go
type error interface
{
    Error() string
}
```

만약 함수가 결과와 에러를 함께 리턴한다면, 이 에러가 nil 인지를 체크해서 에러가 존재여부를 체크할 수 있습니다. 
예를 들어, os.Open() 함수는 `func Open(name string) (file *File, err error)` 과 같은 함수 원형을 갖는데, 첫번째는 File 포인터 리턴하고 두번째는 error 인터페이스를 리턴합니다. 그래서 이 경우에서는 두번째 error를 체크해서 `nil 이면 에러가 없는 것`이고, nil 이 아니면 err.Error() 로부터 해당 에러를 확인할 수 있습니다. 
아래 예제는 파일을 오픈하는데 에러가 발생하면 에러메시지를 출력하고 빠져나가는 예입니다. (주: log.Fatal() 은 메시지를 출력하고 os.Exit(1)을 호출하여 프로그램을 종료한다)
```go
func main() {
	f, err := os.Open("C:\\workspace\\go-study-mysterico\\README.md")
	if err != nil {
		log.Fatal(err.Error())
	}
	// println(f.Name())
}
```
output
```shell
.\os-open.go:9:2: f declared but not used
```

예시로 들었던 os.Open 함수처럼 Go의 내장 함수나 기본 라이브러리의 대부분의 함수와 메서드는 에러가 발생할 수 있다면 `error 값을 함께 반환`하도록 작성되어 있습니다.